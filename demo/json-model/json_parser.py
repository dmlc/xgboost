"""Demonstration for parsing JSON/UBJSON tree model file generated by XGBoost.
"""

import argparse
import json
from typing import Any, Dict, List, Literal, Sequence, Tuple, Union
from collections import namedtuple

import numpy as np
try:
    import ubjson
except ImportError:
    ubjson = None


ParamT = Dict[str, str]


class Node:
    def __init__(self, left, right):
        self.left = left


class Tree:
    """A tree built by XGBoost."""

    # Index into node array
    _left: Literal[0]
    _right: Literal[1]
    _parent: Literal[2]
    _ind: Literal[3]
    _cond: Literal[4]
    _default_left: Literal[5]
    # Index into stat array
    _loss_chg = 0
    _sum_hess = 1
    _base_weight = 2

    def __init__(
        self,
        tree_id: int,
        nodes: Sequence[Tuple[int, int, int, int, float, int]],
        stats: Sequence[Tuple[float, float, float]],
    ):
        self.tree_id = tree_id
        self.nodes = nodes
        self.stats = stats

    def loss_change(self, node_id: int) -> float:
        """Loss gain of a node."""
        return self.stats[node_id][self._loss_chg]

    def sum_hessian(self, node_id: int) -> float:
        """Sum Hessian of a node."""
        return self.stats[node_id][self._sum_hess]

    def base_weight(self, node_id: int) -> float:
        """Base weight of a node."""
        return self.stats[node_id][self._base_weight]

    def split_index(self, node_id: int) -> int:
        """Split feature index of node."""
        return self.nodes[node_id][self._ind]

    def split_condition(self, node_id: int) -> float:
        """Split value of a node."""
        return self.nodes[node_id][self._cond]

    def parent(self, node_id: int) -> int:
        """Parent ID of a node."""
        return self.nodes[node_id][self._parent]

    def left_child(self, node_id: int) -> int:
        """Left child ID of a node."""
        return self.nodes[node_id][self._left]

    def right_child(self, node_id: int) -> int:
        """Right child ID of a node."""
        return self.nodes[node_id][self._right]

    def is_leaf(self, node_id: int) -> bool:
        """Whether a node is leaf."""
        return self.nodes[node_id][self._left] == -1

    def is_deleted(self, node_id: int) -> bool:
        """Whether a node is deleted."""
        return self.nodes[node_id][self._ind] == np.iinfo(np.uint32).max

    def __str__(self) -> str:
        stacks = [0]
        nodes = []
        while stacks:
            node: Dict[str, Union[float, int]] = {}
            nid = stacks.pop()

            node["node id"] = nid
            node["gain"] = self.loss_change(nid)
            node["cover"] = self.sum_hessian(nid)
            nodes.append(node)

            if not self.is_leaf(nid) and not self.is_deleted(nid):
                left = self.left_child(nid)
                right = self.right_child(nid)
                stacks.append(left)
                stacks.append(right)

        string = "\n".join(map(lambda x: "  " + str(x), nodes))
        return string


class Model:
    """Gradient boosted tree model."""

    def __init__(self, model: dict):
        """Construct the Model from JSON object.

        parameters
        ----------
         m: A dictionary loaded by json
        """
        # Basic property of a model
        self.learner_model_shape: ParamT = model["learner"]["learner_model_param"]
        self.num_output_group = int(self.learner_model_shape["num_class"])
        self.num_feature = int(self.learner_model_shape["num_feature"])
        self.base_score = float(self.learner_model_shape["base_score"])
        # A field encoding which output group a tree belongs
        self.tree_info = model["learner"]["gradient_booster"]["model"]["tree_info"]

        model_shape: ParamT = model["learner"]["gradient_booster"]["model"][
            "gbtree_model_param"
        ]

        # JSON representation of trees
        j_trees = model["learner"]["gradient_booster"]["model"]["trees"]

        # Load the trees
        self.num_trees = int(model_shape["num_trees"])
        self.leaf_size = int(model_shape["size_leaf_vector"])
        # Right now XGBoost doesn't support vector leaf yet
        assert self.leaf_size == 0, str(self.leaf_size)

        trees = []
        for i in range(self.num_trees):
            tree: Dict[str, Any] = j_trees[i]
            tree_id = int(tree["id"])
            assert tree_id == i, (tree_id, i)
            # properties
            left_children: List[int] = tree["left_children"]
            right_children: List[int] = tree["right_children"]
            parents: List[int] = tree["parents"]
            split_conditions: List[float] = tree["split_conditions"]
            split_indices: List[int] = tree["split_indices"]
            # when ubjson is used, this is a byte array with each element as uint8
            default_left = [int(b) for b in tree["default_left"]]
            # categorical features
            split_types: List[int] = [int(b) for b in tree["split_type"]]
            cat_segments = tree["categories_segments"]
            cat_sizes = tree["categories_segments"]
            cat_nodes = tree["categories_nodes"]
            cats = tree["categories"]
            for node_id in range(len(left_children)):
                print(split_types[i])
                if split_types[i] == 1:
                    print("is cat")

            for i in range(0, len(cat_segments)):
                beg = cat_segments[i]
                size = cat_sizes[i]
                end = beg + size
                node_cats = cats[beg: end]
                # print(node_cats)

            # stats
            base_weights: List[float] = tree["base_weights"]
            loss_changes: List[float] = tree["loss_changes"]
            sum_hessian: List[float] = tree["sum_hessian"]

            stats: List[Tuple[float, float, float]] = []
            nodes: List[Tuple[int, int, int, int, float, int]] = []
            # We resemble the structure used inside XGBoost, which is similar
            # to adjacency list.
            for node_id in range(len(left_children)):
                nodes.append(
                    (
                        left_children[node_id],
                        right_children[node_id],
                        parents[node_id],
                        split_indices[node_id],
                        split_conditions[node_id],
                        default_left[node_id],
                    )
                )
                stats.append(
                    (loss_changes[node_id], sum_hessian[node_id], base_weights[node_id])
                )

            pytree = Tree(tree_id, nodes, stats)
            trees.append(pytree)

        self.trees = trees

    def print_model(self) -> None:
        for i, tree in enumerate(self.trees):
            print("tree_id:", i)
            print(tree)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Demonstration for loading XGBoost JSON/UBJSON model."
    )
    parser.add_argument(
        "--model", type=str, required=True, help="Path to .json/.ubj model file."
    )
    args = parser.parse_args()
    if args.model.endswith("json"):
        # use json format
        with open(args.model, "r") as fd:
            model = json.load(fd)
    elif args.model.endswith("ubj"):
        if ubjson is None:
            raise ImportError("ubjson is not installed.")
        # use ubjson format
        with open(args.model, "rb") as bfd:
            model = ubjson.load(bfd)
    else:
        raise ValueError(
            "Unexpected file extension. Supported file extension are json and ubj."
        )
    model = Model(model)
    # model.print_model()
