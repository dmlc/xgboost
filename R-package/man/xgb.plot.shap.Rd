% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xgb.plot.shap.R
\name{xgb.plot.shap}
\alias{xgb.plot.shap}
\title{Partial dependency-like plots of SHAP contributions}
\usage{
xgb.plot.shap(data, shap_contrib = NULL, model = NULL, trees = NULL,
  approxcontrib = FALSE, target_class = NULL, features = NULL,
  top_n = 1, n_col = 1, col = rgb(0, 0, 1, 0.2), pch = ".",
  discrete_n_uniq = 5, discrete_jitter = 0.01, ylab = "SHAP",
  plot_NA = TRUE, col_NA = rgb(0.7, 0, 1, 0.6), pch_NA = ".",
  pos_NA = 1.07, plot_loess = TRUE, col_loess = 2, span_loess = 0.5,
  which = c("1d", "2d"), plot = TRUE, ...)
}
\arguments{
\item{data}{data as a \code{matrix} or \code{dgCMatrix}.}

\item{shap_contrib}{individual case SHAP contributions that was previously obtained as by running
\code{\link{predict.xgb.Booster}} with the above \code{data} and \code{predcontrib = TRUE}.
When it is NULL, it is computed internally using the provided \code{model} and \code{data}.}

\item{model}{a \code{xgb.Booster} model generated by the \code{xgb.train} function.}

\item{trees}{passed to \code{\link{xgb.importance}} when \code{features = NULL}.}

\item{approxcontrib}{passed to \code{\link{xgb.importance}} when \code{features = NULL}.}

\item{target_class}{passed to \code{\link{xgb.importance}} when \code{features = NULL}.}

\item{features}{either column indices or names of features to plot. If NULL, it is internally 
determined using the \code{top_n} parameter.}

\item{top_n}{when \code{features} is NULL, top_n highest ranked by importance features are chosen
by running \code{\link{xgb.importance}} internally.}

\item{n_col}{a number of columns in a grid of plots.}

\item{col}{color of the scatterplot markers.}

\item{pch}{scatterplot marker.}

\item{discrete_n_uniq}{a maximal number of unique values in a feature to consider it as discrete.}

\item{discrete_jitter}{an \code{amount} parameter of jitter added to discrete features' positions.}

\item{ylab}{a y-axis label in 1D plots.}

\item{plot_NA}{whether the contributions for feature missing values should also be plotted.}

\item{col_NA}{a color of markers for missing values.}

\item{pch_NA}{a marker type for NA values.}

\item{pos_NA}{a factor that defines values to "impute" NA with in the plots. The points for 
missing values would be shown at \code{min(x) + (max(x) - min(x)) * pos_NA}.}

\item{plot_loess}{whether to plot loess-smoothed curves. The smoothing is only done for features with
over 5 distinct values.}

\item{col_loess}{a color to use for the loess curves.}

\item{span_loess}{the \code{span} paramerer in \code{\link{stats::loess()}}s calls.}

\item{which}{whether to do univariate or bivariate plotting. NOTE: only 1D is so far implemented.}

\item{plot}{whether a plot should be drawn. If FALSE, only a lits of matrices is returned.}

\item{...}{other parameters passed to \code{plot}.}
}
\value{
Other than producing plots (when \code{plot=TRUE}), it silently returns a list of two matrices:
\itemize{
 \item \code{data} has the values of selected features;
 \item \code{shap_contrib} has the contributions of selected features.
}
}
\description{
Visualizations of how features' contributions to predictions depend on features values.
The concept is similar to partial dependency plots, but the SHAP contributions are always 
shown on the scale of margin.
}
\details{
TODO
}
\examples{

data(agaricus.train, package='xgboost')

bst <- xgboost(agaricus.train$data, agaricus.train$label, nrounds = 50, 
               eta = 0.1, max_depth = 3, subsample = .5,
               method = "hist", objective = "binary:logistic", nthread = 2, verbose = 0)

contr <- predict(bst, agaricus.test$data, predcontrib = TRUE)
xgb.plot.shap(agaricus.test$data, contr, model = bst, top_n = 12, n_col = 3)

# multiclass example - plots for each class separately:
nclass <- 3
nrounds <- 10
x <- as.matrix(iris[, -5])
mbst <- xgboost(data = x, label = as.numeric(iris$Species) - 1,
                nrounds = 20, max_depth = 2, eta = 0.3, subsample = .5, nthread = 2,
                objective = "multi:softprob", num_class = nclass, verbose = 0)
tree_seq0 <- seq(from=0, by=nclass, length.out=nrounds)
col <- rgb(0, 0, 1, 0.5)
xgb.plot.shap(x, model = mbst, trees = tree_seq0, target_class = 0, top_n = 4, n_col = 2, col = col, pch = 16)
xgb.plot.shap(x, model = mbst, trees = tree_seq0 + 1, target_class = 1, top_n = 4, n_col = 2, col = col, pch = 16)
xgb.plot.shap(x, model = mbst, trees = tree_seq0 + 2, target_class = 2, top_n = 4, n_col = 2, col = col, pch = 16)

}
